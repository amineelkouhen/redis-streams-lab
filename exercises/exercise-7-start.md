<img src="../img/redis-logo-full-color-rgb.png" height=100/>

# Exercise 7 - real-time data in action in a complete app: RedisBank

In this exercise we will put everything that we've learned together as well as adding a few more interesting features. We'll be building a real application this time so let's get started! For this part we've provided you with a basic scaffolding application with a fully functional front-end which can be found [over here](exercise7-start/). This will be the starting point for this exercise. You will be building the backend to make the whole application fully functional. We also provided a separate app for test data generation that can be found [over here](exercise7-datageneration) Last, but not least, you can find a fully working solution [over here](exercise7-solution).

## Architecture
Data generation app -> Generates bank transactions and puts them on a Redis Stream. It also populates a RediSearch index and creates a TimeSeries for the account balance and a Sorted Set for the 'biggest spenders' on the account. The transactions Stream is stored under a key called `transactions`, the TimeSeries under a key called `balance_ts`, the Sorted Set under a key called `bigspenders` and the search indices under a general key. 

The app that we're going to be working on will consume these data structures and show them in a UI (which has been provided).

You can view a picture of the overall architecture [over here](../img/architecture.png).

## Getting started

Assuming you still have Redis running in GitPod, all we have to do is compile the app and run it.

From the *exercise7-start* folder in the terminal window:

- `./mvnw clean package` 
- `./mvnw spring-boot:run` to build and run the app

This app hosts a website at port 8080. Try to connect to it, and pass the login page with user `lars` and password `larsje`. You should be able to login, but the following screen is still kind of empty. So let's stop the app for now, and then do something about that!

### Consuming a Redis Stream
* Consume the transactions Stream

A [Redis Stream](https://redis.io/topics/streams-intro) is an append-only log. The [data generator](https://github.com/ruurdk/redisbank/blob/basicstart/src/main/java/com/redislabs/demos/redisbank/transactions/BankTransactionGenerator.java#L117) will put transaction on the Stream, and our application will subscribe to this Stream and will consume any income transactions.

The only thing we have to do now is store them as JSON in Redis and send them to the frontend over a Websocket connection. The magic happens in the [onMessage method](https://github.com/ruurdk/redisbank/blob/basicstart/src/main/java/com/redislabs/demos/redisbank/transactions/BankTransactionForwarder.java#L57)

In here, include the code to do just that:
```java
try {
    // if we need an object we could do this but we can use native String/JSON as well
    // BankTransaction bankTransaction = SerializationUtil.deserializeObject(messageString, BankTransaction.class);
    RedisJSONCommands<String, String> red = redismod.sync();
    red.jsonSet("RedisBank:BankTransaction:"+ message.getId().getValue(),
        ".", // JSON Path
        messageString
    );
} catch (Exception e) {
    LOGGER.error("Error parsing JSON: {}", e.getMessage());
}

// Stream message to websocket connection topic
smso.convertAndSend(config.getStomp().getTransactionsTopic(), message.getValue());
LOGGER.info("Websocket message: {}", messageString);
```

And that's it for this part. Now let's see how that looks in our application. Build and run our app:

```
./mvnw clean package
./mvnw spring-boot-run
```

If all is well, if you navigate to http://localhost:8080 and log in using `lars/larsje`, you should now see an overview of transactions and a few not-yet functional bits (because we will be enabling those next!). If all is well you should see new transactions popping in every ten seconds or so. If not, check your source code and see if you missed any annotations or other parts. Next, let's add the search feature! 

### Adding RediSearch capabilities

* Start by stopping our banking app.
* In the existing `TransactionOverviewController` class we've provided most of the scaffolding for you so you can focus on building in the Redis and Lettuce bits.
* Inside the `searchTransactions(@RequestParam("term") String term)` method, we'll use RediSearch to search the transactions generated by the data generation app and present them onto the UI. We will do so by adding the following code:


```java
RediSearchCommands<String, String> commands = srsc.sync();

// optional options
SearchOptions options = SearchOptions.builder().build();

results = commands.search(BankTransactionGenerator.SEARCH_INDEX, term, options);
```

There are quite a few things going on here but what does this all mean? The first statement opens a RediSearch connection using the RediSearch client library (already on the classpath). The second one creates SearchOptions, based on our preferences. Check out `BankTransactionGenerator.SEARCH_INDEX` to see how we're searching the description, transactionType and fromAccountName fields of the `BankTransaction`. 
The third statement executes the search and returns the results. 

* Now let's run our banking app. Then navigate to http://localhost:8080 and try out the search. 
* Enter the letters `onli` in the search box and see what happens. Notice how it selects all transactions of Type `Online payment` and highlights the word `Online`.
* Now enter the letters `paym` in the search box and see what happens. Notice how it selects all transactions with the word `payment` in either the Description or Type.
* Now enter the letters `BMW` in the search box and see what happens. Notice how it selects all transactions with the word `BMW` in the Name field.
* Play around with the search a bit more if you want or move on to the next part.

### Adding the balance over time view

Now that we've got the search and the transaction overview working, let's do the balance over time view. The data generation also populates a TimeSeries for the bank accounts balance, updating the TimeSeries every time there is a new transaction. We can query this TimeSeries and pass the result to the UI so it can show the balance over time in a nice visual diagram. Let's get started:

* Stop the app.
* In the `TransactionOverviewController` class in the `balance()` method, add the following:

```java
List<Sample> tsValues = srsc.sync().range(BALANCE_TS,
        TimeRange.from(System.currentTimeMillis() - (1000 * 60 * 60 * 24 * 7))
                .to(System.currentTimeMillis()).build());
Balance[] balanceTs = new Balance[tsValues.size()];
int i = 0;

for (Sample entry : tsValues) {
    Object keyString = entry.getTimestamp();
    Object valueString = entry.getValue();
    balanceTs[i] = new Balance(keyString, valueString);
    i++;
}

return balanceTs;
```

What we're doing here is asking "Give us the time series values stored under the key of BALANCE_TS between now and (now -1 week)". We then copy the results into a `Balance` array (the UI requests the data in this format for display) and return it. 

* Build and run the app and see the balance over time populated. Also notice how it updates with each incoming transaction.

### Adding the 'biggest spenders' feature to the app

Now, last, but certainly not least, let's add the 'biggest spenders' functionality. This will show the biggest deductors from your bank account, in other words: 'where is my money going?' For this purpose, the data-generation is populating a Sorted Set. For every transaction it will add the value of the transaction to a member to the sorted set of which the key is the counter-account's name and the value is the total amount of the transactions for that account. That means that the set is ordered by the total amount of transactions for that account, so we can show the 'biggest spenders' on our account, or 'where is my money going?'!

* Stop the app.
* In the `biggestSpenders()` method, add the following code:

```java
Set<TypedTuple<String>> range = redis.opsForZSet().rangeByScoreWithScores(SORTED_SET_KEY, 0, Double.MAX_VALUE);
if (range.size() > 0) {
    BiggestSpenders biggestSpenders = new BiggestSpenders(range.size());
    int i = 0;
    for (TypedTuple<String> typedTuple : range) {
        biggestSpenders.getSeries()[i] = Math.floor(typedTuple.getScore() * 100) / 100;
        biggestSpenders.getLabels()[i] = typedTuple.getValue();
        i++;
    }
    return biggestSpenders;
} else {
    return new BiggestSpenders(0);
}
```

This will retrieve the members of the Sorted Set by their scores from 0 up to `Double.MAX_VALUE`. We then put the result in a `BiggestSpenders` object (which is suitable for the UI component to display).

* Build and run the app, and watch in awe as the biggest spenders are now shown in the app!

## What's happening in Redis?

Let's take a look at what's happening in Redis while we did this. First we'll take a look at what the data generation is populating. Let's use the Redis CLI to check out what's going on under the hood.

### Redis Stream

The data generation app generates a bank transaction every 10 seconds or so and puts in on a Stream. You can query the stream using:

```
xread count 10000 streams transactions 0-0
```

This will give all of the entries on the `transactions` Stream (assuming you have less than 10000 items of course). Remember that our app subscribed to this Stream via Spring Data, so every time a new element is added to the Stream it's being processed by our app and sent to the UI.

### Sorted Set

The data generation app also adds every transaction to a Sorted Set. It's adding the transaction amount to the score, and the key of the member of the set is the name of the account. So it adds up all the transaction amounts per account name and stores this in a Sorted Set. So we can get the biggest spenders out by simply querying the Sorted Set like this:

```
zrangebyscore bigspenders 0 10000 withscores
```

### TimeSeries

The data generation app also adds the bank accounts balance to a TimeSeries every time there is a new transaction being generated. This allows us to view the balance over time using a query such as:

```
ts.range balance_ts 1623000000000 1653230682038 (use appropriate timestamps or it will return an empty array)
```

In the example we don't do any of the advanced features like compacting or aggregation, but feel free to take a look at the [documentation](https://oss.redis.com/redistimeseries/) to learn more about those topics.

### Hashes

To be able to search transactions, each transaction is also stored as JSON in Redis (in the RedisBank:BankTransaction keyspace), so it can be indexed by RediSearch so we can search them, e.g. like:

```
ft.search transaction_description_idx Fuel
```

### Session data

Last, but not least, session data is also stored in Redis. This required no code from our end whatsoever, adding the dependencies is enough.


## Next steps

Congrats! You made it to the end of our workshop.

By now you should have a solid overview of Redis data types, ways to interact (CLI, GUI, Java and client options). 

On top of that we also explored some use cases ranging from Redis as a cache to a modern real-time database.